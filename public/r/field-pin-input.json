{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "field-pin-input",
  "type": "registry:block",
  "title": "Field Pin Input",
  "description": "A minimal 4-digit PIN input field using custom hooks for sibling input logic.",
  "dependencies": [
    "@mui/material",
    "@emotion/react",
    "@emotion/styled"
  ],
  "registryDependencies": [
    "https://mui-registry.vercel.app/r/input-siblings.json"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/field-pin-input/field-pin-input.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport Box, { BoxProps } from \"@mui/material/Box\";\nimport FilledInput from \"@mui/material/FilledInput\";\nimport {\n  usePinInput,\n  UsePinInputOptions,\n} from \"@/registry/new-york/blocks/field-pin-input/hooks/usePinInput\";\n\ntype PinInputProps = {\n  children: Array<React.ReactElement>;\n} & Omit<BoxProps, \"children\"> &\n  Omit<UsePinInputOptions, \"pinLength\">;\n\nconst PinInput = React.forwardRef<\n  HTMLDivElement,\n  React.PropsWithChildren<PinInputProps>\n>(function PinInput(props, ref) {\n  const { children, onChange, onBlur, ...other } = props;\n  const { pins } = usePinInput({ ...props, pinLength: children.length });\n\n  return (\n    <Box\n      ref={ref}\n      {...other}\n      sx={{\n        display: \"flex\",\n        gap: \"0.5rem\",\n        \"& input\": {\n          textAlign: \"center\",\n          caretColor: \"transparent\",\n        },\n        \"& .Mui-focused\": {\n          outline: \"1px solid\",\n          background: \"transparent\",\n        },\n      }}\n    >\n      {pins.map((getInputProps, index) => {\n        const inputElement = children[index];\n        return (\n          <React.Fragment key={index}>\n            {React.cloneElement(inputElement, {\n              // @ts-ignore\n              inputProps: getInputProps({\n                // @ts-ignore\n                ...inputElement.props.inputProps,\n              }),\n            })}\n          </React.Fragment>\n        );\n      })}\n    </Box>\n  );\n});\n\nexport function FieldPinInput() {\n  return (\n    <PinInput>\n      <FilledInput disableUnderline hiddenLabel />\n      <FilledInput disableUnderline hiddenLabel />\n      <FilledInput disableUnderline hiddenLabel />\n      <FilledInput disableUnderline hiddenLabel />\n    </PinInput>\n  );\n}\n",
      "type": "registry:block"
    },
    {
      "path": "registry/new-york/blocks/field-pin-input/hooks/usePinInput.ts",
      "content": "import React from \"react\";\nimport { useInputSiblings } from \"@/registry/new-york/blocks/input-siblings/hooks/useInputSiblings/useInputSiblings\";\nimport {\n  useIsFirstMount,\n  useInput,\n} from \"@/registry/new-york/blocks/input-siblings/hooks/useInputSiblings/useInput\";\nimport type { InputHanders } from \"@/registry/new-york/blocks/input-siblings/hooks/useInputSiblings/types\";\n\nconst numberValidator = (value: string) => new RegExp(/\\d/).test(value);\nconst alphanumericValidator = (value: string) =>\n  new RegExp(/[a-zA-Z0-9]/).test(value);\n\nexport interface UsePinInputOptions {\n  /**\n   * If `true`, the input will be focused\n   */\n  autoFocus?: boolean;\n  /**\n   * The type of values the pin-input should allow\n   */\n  type?: \"number\" | \"alphanumeric\";\n  /**\n   * If `true`, the input's value will be masked just like `type=password`\n   */\n  mask?: boolean;\n  /**\n   * If `true`, the pin input component signals to its fields that they should use `autocomplete=\"one-time-code\"`.\n   */\n  otp?: boolean;\n  /**\n   * number of pin inputs (this number should never change between render)\n   */\n  pinLength?: number;\n  /**\n   * initial value (don't use together with `value`)\n   */\n  defaultValue?: string;\n  /**\n   * value for controlled input\n   */\n  value?: string;\n  /**\n   * a callback function when input value changed\n   */\n  onChange?: (value: string, meta: { invalid: boolean }) => void;\n  /**\n   * a callback function when all inputs are not focused\n   */\n  onBlur?: (event: React.FocusEvent<HTMLInputElement>) => void;\n}\n\nexport const usePinInput = (options: UsePinInputOptions = {}) => {\n  const {\n    pinLength = 4,\n    defaultValue,\n    value,\n    type = \"number\",\n    mask = false,\n  } = options;\n  const validator = type === \"number\" ? numberValidator : alphanumericValidator;\n  const splittedValue = (value || defaultValue || \"\").split(\"\");\n  const siblings = [...Array(pinLength).fill(undefined)].map((_, index) =>\n    useInput({\n      autoFocus: options.autoFocus && index === 0,\n      maxLength: 1,\n      validator,\n      value: splittedValue[index],\n    })\n  );\n\n  const isFirstMount = useIsFirstMount();\n  const pinArray = siblings.map(({ value }) => value);\n  React.useEffect(() => {\n    if (!isFirstMount) {\n      options.onChange?.(pinArray.join(\"\"), {\n        invalid: siblings.some((pinInput) => pinInput.invalid),\n      });\n    }\n  }, pinArray);\n\n  const pins = useInputSiblings({\n    siblings,\n    onBlur: options?.onBlur,\n  });\n\n  return {\n    pins: pins.map((getInputProps) => {\n      return (handlers?: InputHanders) => {\n        const inputProps = getInputProps(handlers);\n        return {\n          \"aria-label\": \"Please enter your pin code\",\n          size: 1,\n          type: mask ? \"password\" : \"tel\",\n          pattern: \"d\",\n          placeholder: \"â—‹\",\n          inputMode: \"numeric\" as const,\n          autoComplete: options.otp ? \"one-time-code\" : \"off\",\n          ...inputProps,\n          onChange: (event: React.ChangeEvent<HTMLInputElement>) => {\n            let inputValue = event.target.value;\n            if (inputValue.length > 2) {\n              inputValue =\n                inputValue[0] === inputProps.value\n                  ? inputValue.slice(1)\n                  : inputValue.substring(-1);\n              handlers?.onChange?.(event);\n              // copy & paste\n              const valueArray = inputValue\n                .split(\"\")\n                .filter(validator)\n                .slice(0, siblings.length);\n              valueArray.forEach((val, index) => {\n                siblings[index].setValue(val);\n              });\n              const nextInput =\n                siblings[\n                  Math.min(valueArray.length, siblings.length - 1)\n                ].getDOM();\n              if (nextInput) nextInput.focus();\n            } else {\n              inputProps.onChange(event);\n            }\n          },\n        };\n      };\n    }),\n  };\n};\n",
      "type": "registry:hook"
    }
  ]
}